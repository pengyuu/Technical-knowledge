# 热修复笔记

热修复主要分为三大领域：代码修复、资源修复、so修复

### 代码修复

代码修复有两大主要方案，一种是阿里系的底层替换方案，另一种是腾讯系的类加载方案。

这两个方案各有优劣：
 - 底层替换方案限制颇多，但时效性最好，加载轻快，立即见效。
 - 类加载方案时效性差，需要重新冷启动才能见效，但修复范围广，限制少

#### 底层替换方案

底层替换方案是在已经加载了的类中直接替换掉原有的方法，是在原来类的基础上进行修改的。因而无法实现对原有类进行方法和字段增减，因为这样将破坏原有类的结构。

一旦补丁类中出现了方法的增加和减少，就会导致这个类以及整个 Dex 的方法数的变化。方法数的变化伴随着方法索引的变化，这样在访问方法时就无法正常的索引到正确的方法了。如果字段发生了增加和减少，和方法变化的情况一样，所有字段的索引都会发生变化。并且更严重的问题是，如果在程序运行中间某个类突然增加了一个字段，那么对于原先已经产生的这个类的实例，它们还是原来的结构，这是无法改变的。而新方法使用到这些老的实例对象时，访问新增字段就会产生不可预期的结果。

这是这类方案的固有限制，而底层替换方案作为人诟病的地方，在于底层替换的不稳定性。

传统的底层替换方式，不论是 Dexposed、Andfix 或者其他安全界的 Hook 方案，都是直接依赖修改虚拟机方法实体的具体字段。例如，改 Davilk 方法的 jni 函数指针、改类或方法的访问权限等等。这样就带来一个很严重的问题，由于Android时开源的，各个手机厂商都可以对代码进行改造，而 Andfix 里 ArtMethod 的结构体进行类修改，就和原先开源代码里的结构不一致，那么在这个修改过了的设备上，通用性的替换机制就会出问题。这便是不稳定的根源。

#### 类加载方案

类加载方案的原理是在 app 重新启动后让 Classloader 去加载新的类。因为在 app 运行到一半的时候，所有需要发生变更的类已经被加载过了，在 Android 上是无法对一个类进行卸载的。如果补充其，原来的类还在虚拟机中，就无法加载新类。因此，只有在下次重启的时候，在还没走到业务逻辑之前抢先加载补丁中的新类，这样后续访问这个类时，就会Resolve为新类。从而达到热修复的目的。


比较典型的就是Tinker，微信的Tinker方案使用的类加载方案是完整的全量 dex 加载，并且可谓是将补丁合成做到了极致，不过过于精密使得 Tinker 适于使用的场景有很大的限制。Tinker 的合成方案，是从 dex 的方法和指令维度进行全量合成，整个过程都是自己研发的。虽然可以很大地节省空间，但由于对 dex 内容的比较粒度过细，实现较为复杂，性能消耗比较严重。实际上，dex 的大小占整个 apk 的比例是比较低的，一个 app 里面的 dex 文件大小并不是主要部分，而占空间大的主要还是资源文件。因此，Tinker 方案的时空代价转换的性价比不高。

其实，dex 比较的最佳粒度，应该是在类的维度。它既不像方法和指令维度那样的细微，也不像 bsbiff 比较那般的粗糙。在类的维度，可以达到时间和空间平衡道德最佳效果。

Sophix采用的也是全量合成 dex 的技术，直接利用 Android 原先的类查找和合成机制，快速合成新的全量 dex。这种方法既不需要处理合成时方法数超过的情况，对于 dex 的结构也不用进行破坏性重构。Sophix重新编排类包中 dex 的顺序。这样，在虚拟机查找类的时候，会优先找到 classes.dex 中的类，然后才是 classes2.dex、classes3.dex，也可以看作是 dex 文件级别的类插状方案。这个方案十分巧妙，它对旧包与补丁包中的 classes.dex 的顺序进行了打破与重组，最终使得系统可以自然地识别这个顺序，以实现类覆盖的目的，这将会大大减少合成补丁的开销。

### 资源修复

Instant Run 中的资源热修复分为两步：
 1. 构造一个新的 AssetManager，并通过反射调用 addAssetPath，把这个完整的新资源包加入到 AssetManager 中。这样就得到了一个含有所有新资源的 AssetManager。
 2. 找到所有之前引用到原有 AssetManager 的地方，通过反射，把引用处替换为 AssetManager。

其实大量代码都是在处理兼容性问题和找到所有 AssetManager 的引用处，真正的替换的逻辑其实很简单。

### SO 库修复

SO 库的修复本质上是对 native 方法的修复和替换。
