# 热修复工具对比

在 Android 平台上，比较著名的热修复技术有: 阿里系的 Andfix、Hotfix、Sophix，腾讯QQ空间的超级补丁技术，微信的 Tinker，饿了么的Amigo，美团的Robust等等。

现在比较好的几种热修复方案比较: Sophix、Tinker、Amigo

|  方案对比   |                Sophix                |        Tinker        |        Amigo(官方已停止支持)         |
|:-----------:|:------------------------------------:|:--------------------:|:--------------------:|
|  Dex 修复   |         即时生效/冷启动修复          |      冷启动修复      |      冷启动修复      |
|  资源更新   |           差量包，不用合成           |   差量包，需要合成   |   全量包，不用合成   |
|  so 库更新  |          插桩实现，开发透明          | 替换接口，开发不透明 |  插桩实现，开发透明  |
|  性能损耗   |      低，仅冷启动情况下有些损耗      |    高，有合成操作    |     低，全量替换     |
|  四大组件   |               不能增加               |       不能增加       |        能增加        |
|  生成补丁   | 直接选择已经编译好的新旧包在本地生成 | 编译新包时设置基线包 | 上传完整新包到服务端 |
|  补丁大小   |                  小                  |          小          |          大          |
|  接入成本   |              傻瓜式接入              |         复杂         |         一般         |
| Android版本 |               全部支持               |       全部支持       |       全部支持       |
|  安全机制   |          加密传输及签名校验          |  加密传输及签名校验  |  加密传输及签名校验  |
| 服务端支持  |            支持服务端控制            |    支持服务端控制    |    支持服务端控制    |

Sophix 方案纵向比较

|   方案对比   |      Andfix开源版本      |      阿里Hotfix 1.x      |          阿里Sophix          |
|:------------:|:------------------------:|:------------------------:|:--------------------------------:|
|   方法替换   | 支持，除部分情况 (注[0]) | 支持，除部分情况 (注[0]) |             全部支持             |
| 方法增加减少 |          不支持          |          不支持          |    以冷启动方式支持  (注[1])     |
| 方法反射调用 |      只支持静态方法      |      只支持静态方法      |         以冷启动方式支持         |
|   即时生效   |           支持           |           支持           |       视情况支持  (注[2])        |
|    多DEX     |          不支持          |           支持           |               支持               |
|   资源更新   |          不支持          |          不支持          |               支持               |
|  so 库更新   |          不支持          |          不支持          |               支持               |
| Android版本  |      支持 2.3 ~ 7.0      |      支持 2.3 ~ 6.0      |     全部支持, 包含 7.0 以上      |
|   已有机型   |    大部分支持 (注[3])    |        大部分支持        |             全部支持             |
|   安全机制   |            无            |    加密传输及签名校验    |        加密传输及签名校验        |
|   性能损耗   |      低，近乎无损耗      |      低，近乎无损耗      |    低，仅冷启动情况下有些损耗    |
|   生成补丁   |     繁琐，命令行操作     |     繁琐，命令行操作     |         便捷，图形化界面         |
|   补丁大小   |     不大，仅变动的类     |     小，仅变动的方法     | 不大，仅变动的资源和代码 (注[4]) |
|  服务端支持  |            无            |  支持服务端控制 (注[5])  |          支持服务端控制          |

说明：

 0. 部分情况指的是构造方法、参数数目大于8或参数包括 long, double, float 基本类型的方法。
 1. 冷启动方式，指的是需重启 app 在下次启动时才能生效。
 2. 对于 Andfix 及 Hotfix 1.x 能够支持的代码变动的情况，都能做到及时生效。而对于 Andfix 及 HotFix 1.x 不支持的代码变动情况，会走冷启动方式，此时就无法做到及时生效。
 3. Hotfix 1.x 已经支持绝大部分主流手机，只是在 X86 设备以及修改了虚拟机底层结构的 ROM 上不支持。
 4. 由于支持了资源和库，如果有这些方面的更新，就会导致补丁变大一些，这个是很正常的。并且由于只包含差异的部分，所以补丁已经是最大程度的小了。
 5. 提供服务端的补丁发布和停发、版本控制和灰度功能、存储开发者上传的补丁包。


### Andfix

 支付宝

 Andfix 是一种底层结构替换的方案，达到了运行时生效即时修复的效果，并且做到了 Dalvik 和 ART 环境的兼容。Andfix 采用的方法是，在已经加载了的类中直接在 native 层替换掉原有的方法，是在原来类的基础上进行修改的。但 Andfix 具有一些局限性，其底层固定结构的替换方案稳定性不好，其使用范围也存在着诸多限制，虽然可以通过改造代码绕过限制来达到相同的修复目的，但这种方式既不优雅也不方便。更大的问题是，Andfix只提供了代码层的修复，对于资源和 so 的修复都还未能实现。

 Andfix自身限制几乎是无法绕过的，在运行时对原有类的结构是已经固化在内存中的，它的一些动态属性很难进行扩展。并且由于Android系统的碎片化，厂商的虚拟机底层结构都不是确定的。

 ### Hotfix

 阿里百川

Hotfix 是阿里百川结合手淘在实际工程中使用 Andfix 的经验，对相关业务逻辑解耦后推出的方案。Hotfix已经是一个不错的产品了，对于基本的代码修复需求都可以解决，安全性和易用性都做的比较好。然而其所依赖的基石--Andfix 本身具有局限性，所以 Hotfix 缺点很明显。

### Sophix

阿里

Sophix 属于非侵入式 Android 热修复方案，Sophix实现了热修复的三大领域: 代码修复，资源修复，so修复，比且考虑到了方案的安全性和易用性。Sophix 的打包过程不会侵入到 apk 的 build 流程中，需要的只有生成完毕的新旧 apk，在生成补丁的过程中间既不会改变任何打包组件，也不插入任何 AOP 代码。在使用 Sophix 时，需要的只是初始化和请求两行代码，甚至 Application 类都不需要做修改。Sophix 还开发了配套的打包工具，使得补丁工具操作图形界面化。接入成本比较低。

##### 代码修复

Sophix 的代码修复也采用了底层替换方式，但实现的是一种无视底层具体结构的替换方式，这种方式解决类兼容性的问题，并且由于忽略类底层 ArtMethod 结构的差异，对于所有的Android版本都不再需要区分，代码量大大减少。即使以后的Android版本不断修改 ArtMethod 的成员，只要保证 ArtMethod 数组仍是以线性结构排列，就能直接适用于将来的 Android 8.0、9.0等新版本，无需再针对新的系统版本进行适配了。

Sophix 类加载采用的也是全量合成 dex 的技术，直接利用 Android 原先的类查找和合成机制，快速合成新的全量 dex。这种方法既不需要处理合成时方法数超过的情况，对于 dex 的结构也不用进行破坏性重构。Sophix重新编排类包中 dex 的顺序。这样，在虚拟机查找类的时候，会优先找到 classes.dex 中的类，然后才是 classes2.dex、classes3.dex，也可以看作是 dex 文件级别的类插状方案。这个方案十分巧妙，它对旧包与补丁包中的 classes.dex 的顺序进行了打破与重组，最终使得系统可以自然地识别这个顺序，以实现类覆盖的目的，这将会大大减少合成补丁的开销。

底层替换和类加载各有优劣，Sophix将其结合使用，可以实现优势互补，灵活的根据实际情况自动切换。在补丁生成阶段，补丁工具会根据实际代码变动情况进行自动选择，针对小修改，在底层替换方案限制范围内的，就直接采用底层替换修复，这样可以做到代码修复即使生效。而对于代码修改超出底层替换限制的，会使用类加载替换，这样虽然及时性没那么好，但总归何以达到热修复的目的。另外运行时阶段，Spohix还会再判断所运行的机型是否支持热修复，这样即使补丁支持热修复，但由于机型底层虚拟机构造不知吃，还是会走类加载修复，从而达到最好的兼容性。

##### 资源修复

Sophix的资源修复方案没有直接使用 Instant Run 的技术，而是另辟蹊径，构造了一个 package id 为 0x66 的资源包，这个包里只包含改变了的资源项，然后直接在原有 AssetManager 中 addAssetPath 这个包就可以了。由于补丁包的 package id 为 0x66，不与目前已经加载的 0x7f 冲突，因此直接加入到已有的 AssetManager 中就可以直接使用了。补丁包里面的资源，只包含原有包里没有而新的包里面有的新增资源，以及原有内容发生了改变的资源。并且 Sophix 采用了更加优雅的替换方式，直接在原有的 AssetManager 对象上进行析构和重构，这样所有原先对 AssetManager 对象的引用是没有发生改变的，所以就不需要像 Instant Run那样进行繁琐的修改了。

 1. 不修改 AssetManager 的引用处，替换更快更完全。（对比 Instant Run 以及所有 copycat的实现）
 2. 不必下发完整包，补丁包中只包含有变动的资源。（对比 Instant Run、Amigo 等方式的实现）
 3. 不需要在运行时合成完整包。不占用运行时计算和内存资源。（对比 Tinker 的实现）

##### SO库修复

Sophix采用的是类似类修复反射注入方式。把补丁 so 库的路径插入到 nativeLibraryDirectories数组的最前面，就能达到加载 so 库的时候是补丁 so 库，而不是原来 so 库的目录，从而达到修复的目的。采用这种方案，完全由 Sophix 在启动期间凡是注入 patch 中的 so 库。对开发者依然是透明的。不用像某些其他方案需要手动替换系统的 System.load 来实现替换的目的。

### QQ空间

QQ空间方案使用的是类加载方案，它会侵入打包流程，并且为了 hack 添加一些无用的信息，实现起来很不优雅。而 QFix 的方案，需要获取底层虚拟机的函数，不够稳定可靠，并且有个比较大的问题是无法新增 public 函数。

### Tinker

Tinker 是微信官方的 Android 热补丁解决方案，它支持动态下发代码、so 库以及资源，让应用能够在不需要重新安装的情况下实现更新。同时也支持更新插件。

##### 代码修复
微信的Tinker方案使用的类加载方案是完整的全量 dex 加载，并且可谓是将补丁合成做到了极致，不过过于精密使得 Tinker 适于使用的场景有很大的限制。Tinker 的合成方案，是从 dex 的方法和指令维度进行全量合成，整个过程都是自己研发的。虽然可以很大地节省空间，但由于对 dex 内容的比较粒度过细，实现较为复杂，性能消耗比较严重。实际上，dex 的大小占整个 apk 的比例是比较低的，一个 app 里面的 dex 文件大小并不是主要部分，而占空间大的主要还是资源文件。因此，Tinker 方案的时空代价转换的性价比不高。

###### 由于原理与系统限制，Tinker有以下已知问题：
 1. Tinker 不支持修改 AndroidManifest.xml，Tinker不支持新增四大组件；
 2. 由于Google Play 的开发者条款限制，不建议在GP渠道动态更新代码；
 3. 在Android N上，补丁对应用启动时间有轻微影响；
 4. 不支持部分三星 android-21 机型，加载补丁时会主动抛出 `TinkerRuntimeException:checkDexInstall failed`；
 5. 由于各个厂商的加固实现并不一致，在 Tinker 1.7.6 以及之后的版本，不再支持加固的动态更新；
 6. 对于资源替换，不支持修改 remoteView。例如 transition 动画、notification icon 以及桌面图标；
